{
  "name": "WF-KEYWORD-RESEARCH: Keyword Discovery & Filter v3",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "keyword-research",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "9902bbac-8a79-4dee-bb77-cf11c3ed3eb4",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -2224,
        96
      ],
      "webhookId": "keyword-research"
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// INPUT VALIDATION\n// ===========================================\nconst body = $json.body || $json;\nconst keyword = body.keyword || body.main_keyword;\nconst projectId = body.project_id;\nconst clientId = body.client_id;\nconst country = (body.country || 'TR').toUpperCase();\nconst language = body.language || 'tr';\nconst customRules = body.custom_rules || '';\n\nif (!keyword || keyword.trim().length < 2) {\n  return [{ json: { \n    isValid: false, \n    error: 'keyword parametresi zorunludur (min 2 karakter)', \n    errorCode: 400 \n  }}];\n}\n\nconst locationCodes = {\n  'TR': 2792, 'US': 2840, 'GB': 2826, 'DE': 2276, 'FR': 2250\n};\n\nreturn [{ json: { \n  isValid: true, \n  keyword: keyword.trim().toLowerCase(),\n  projectId: projectId ? parseInt(projectId) : null,\n  clientId: clientId ? parseInt(clientId) : null,\n  country: country,\n  language: language,\n  locationCode: locationCodes[country] || 2792,\n  customRules: customRules\n}}];"
      },
      "id": "aa92142f-6a42-43f8-90d6-42f7732c52ca",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2000,
        96
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "valid",
              "leftValue": "={{ $json.isValid }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "318aa55f-b2b4-4f1e-a39b-506db0ef4b22",
      "name": "IF Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1776,
        96
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={ \"success\": false, \"error\": \"{{ $json.error }}\" }",
        "options": {
          "responseCode": "={{ $json.errorCode }}"
        }
      },
      "id": "d11d1df2-d9f5-466c-ba34-3bae3d776943",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -1552,
        304
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT \n  COALESCE(cc.enable_ai_analysis, 1) as enable_ai_analysis,\n  cc.ai_model_preference,\n  cc.ai_temperature,\n  sp.prompt_text as filter_prompt\nFROM (SELECT 1 as dummy) d\nLEFT JOIN client_configurations cc ON cc.client_id = {{ $json.clientId || 0 }}\nLEFT JOIN system_prompts sp ON sp.slug = 'keyword-filter' AND sp.is_active = 1\nLIMIT 1",
        "options": {}
      },
      "id": "95dbeb6c-1aa6-4bb7-95bb-e390149cea53",
      "name": "Get Client Config & Prompt",
      "type": "n8n-nodes-base.mySql",
      "typeVersion": 2.4,
      "position": [
        -1552,
        96
      ],
      "credentials": {
        "mySql": {
          "id": "1rDLBK64lV00T0am",
          "name": "SEO Suite MySQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// PREPARE CONFIG FOR API CALLS\n// ===========================================\nconst input = $('Validate Input').first().json;\nconst config = $input.first().json;\n\nreturn [{ json: {\n  ...input,\n  enableAiAnalysis: config.enable_ai_analysis == 1 || config.enable_ai_analysis === null,\n  aiModel: config.ai_model_preference || 'gemini-2.0-flash',\n  aiTemperature: parseFloat(config.ai_temperature) || 0.3,\n  filterPromptTemplate: config.filter_prompt || ''\n}}];"
      },
      "id": "716b9b67-15b7-4d99-b48c-5f845aa91a8a",
      "name": "Prepare Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1344,
        96
      ]
    },
    {
      "parameters": {
        "url": "=http://suggestqueries.google.com/complete/search?client=firefox&q={{ encodeURIComponent($json.keyword) }}&hl={{ $json.language }}&gl={{ $json.country.toLowerCase() }}",
        "options": {
          "timeout": 15000
        }
      },
      "id": "28b889d0-a61d-4492-a801-1915a8d2af95",
      "name": "Google Suggestions",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1120,
        96
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.dataforseo.com/v3/keywords_data/google_ads/keywords_for_keywords/live",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Basic b2t0YXlAc2VvYXJ0LmNvbTo0ODk2ZGRhYzQ2OWUyZjIw"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "=[{\n  \"keywords\": [\"{{ $('Prepare Config').first().json.keyword }}\"],\n  \"location_code\": {{ $('Prepare Config').first().json.locationCode }},\n  \"language_code\": \"{{ $('Prepare Config').first().json.language }}\",\n  \"include_seed_keyword\": true,\n  \"sort_by\": \"search_volume\"\n}]",
        "options": {
          "timeout": 60000
        }
      },
      "id": "fcd6a5cb-6fc1-4ede-bc8f-1f5024c39ee3",
      "name": "DataForSEO Keywords",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -896,
        96
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// MERGE ALL KEYWORD SOURCES + TURKISH NORMALIZATION\n// ===========================================\nconst config = $('Prepare Config').first().json;\nconst mainKeyword = config.keyword;\n\nfunction normalizeForComparison(str) {\n  return str.toLowerCase()\n    .replace(/Ä±/g, 'i').replace(/Ä°/g, 'i')\n    .replace(/ÅŸ/g, 's').replace(/Åž/g, 's')\n    .replace(/Ã¶/g, 'o').replace(/Ã–/g, 'o')\n    .replace(/Ã¼/g, 'u').replace(/Ãœ/g, 'u')\n    .replace(/Ã§/g, 'c').replace(/Ã‡/g, 'c')\n    .replace(/ÄŸ/g, 'g').replace(/Äž/g, 'g')\n    .replace(/[^a-z0-9\\s]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\nfunction hasTurkishChars(str) {\n  return /[Ä±Ä°ÅŸÅžÃ¶Ã–Ã¼ÃœÃ§Ã‡ÄŸÄž]/.test(str);\n}\n\nlet suggestions = [];\ntry {\n  const sugResponse = $('Google Suggestions').first().json;\n  if (Array.isArray(sugResponse) && Array.isArray(sugResponse[1])) {\n    suggestions = sugResponse[1].map(s => ({\n      keyword: String(s).toLowerCase(),\n      search_volume: null,\n      cpc: null,\n      competition: null,\n      source: 'google_suggest'\n    }));\n  }\n} catch (e) { console.log('Suggestions parse error:', e.message); }\n\nlet dataforseoKeywords = [];\ntry {\n  const dfsResponse = $('DataForSEO Keywords').first().json;\n  if (dfsResponse?.tasks?.[0]?.result && Array.isArray(dfsResponse.tasks[0].result)) {\n    dataforseoKeywords = dfsResponse.tasks[0].result.map(kw => ({\n      keyword: (kw.keyword || '').toLowerCase(),\n      search_volume: kw.search_volume || 0,\n      cpc: kw.cpc || 0,\n      competition: kw.competition || null,\n      competition_index: kw.competition_index || 0,\n      source: 'dataforseo'\n    })).filter(kw => kw.keyword);\n  }\n} catch (e) { console.log('DataForSEO parse error:', e.message); }\n\nconst allKeywords = [...dataforseoKeywords, ...suggestions];\nconst seen = new Map();\n\nallKeywords.forEach(kw => {\n  if (!kw.keyword || kw.keyword.length < 2) return;\n  const normalizedKey = normalizeForComparison(kw.keyword);\n  if (!normalizedKey || normalizedKey.length < 2) return;\n  \n  if (!seen.has(normalizedKey)) {\n    seen.set(normalizedKey, kw);\n  } else {\n    const existing = seen.get(normalizedKey);\n    if (hasTurkishChars(kw.keyword) && !hasTurkishChars(existing.keyword)) {\n      kw.search_volume = kw.search_volume || existing.search_volume;\n      kw.cpc = kw.cpc || existing.cpc;\n      kw.source = existing.source + ',' + kw.source;\n      seen.set(normalizedKey, kw);\n    } else if (kw.search_volume && !existing.search_volume) {\n      existing.search_volume = kw.search_volume;\n      existing.cpc = kw.cpc;\n    }\n  }\n});\n\nconst uniqueKeywords = Array.from(seen.values());\n\nconst mainNormalized = normalizeForComparison(mainKeyword);\nif (!seen.has(mainNormalized)) {\n  uniqueKeywords.unshift({\n    keyword: mainKeyword,\n    search_volume: null,\n    cpc: null,\n    competition: null,\n    source: 'seed'\n  });\n}\n\nreturn [{\n  json: {\n    mainKeyword: mainKeyword,\n    projectId: config.projectId,\n    clientId: config.clientId,\n    country: config.country,\n    language: config.language,\n    customRules: config.customRules,\n    enableAiAnalysis: config.enableAiAnalysis,\n    aiModel: config.aiModel,\n    aiTemperature: config.aiTemperature,\n    filterPromptTemplate: config.filterPromptTemplate,\n    keywords: uniqueKeywords,\n    stats: {\n      total_raw: allKeywords.length,\n      after_dedup: uniqueKeywords.length,\n      from_google_suggest: suggestions.length,\n      from_dataforseo: dataforseoKeywords.length\n    }\n  }\n}];"
      },
      "id": "fe663b95-d188-4b4d-8abf-3b63087067b6",
      "name": "Merge Keywords",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        96
      ]
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// PREPARE FILTER PROMPT FROM DATABASE\n// Uses keyword-filter system prompt\n// v4: Passes ALL keywords for later saving\n// ===========================================\nconst data = $input.first().json;\nconst keywords = data.keywords || [];\nconst mainKeyword = data.mainKeyword;\nconst country = data.country;\nconst language = data.language;\nconst customRules = data.customRules || '';\nlet promptTemplate = data.filterPromptTemplate || '';\n\nif (keywords.length === 0) {\n  return [{ json: { skip: true, message: 'No keywords to filter' } }];\n}\n\nif (!data.enableAiAnalysis) {\n  return [{ json: { skipAi: true, ...data } }];\n}\n\n// Sort ALL keywords by volume\nconst allSortedKeywords = [...keywords]\n  .sort((a, b) => (b.search_volume || 0) - (a.search_volume || 0));\n\n// Only top 150 go to AI for processing\nconst aiKeywords = allSortedKeywords.slice(0, 150);\n// Remaining keywords will be saved as pending\nconst remainingKeywords = allSortedKeywords.slice(150);\n\n// Build keyword CSV for AI\nconst keywordCsv = aiKeywords.map((kw, i) => {\n  const vol = kw.search_volume || 0;\n  const cpc = kw.cpc ? kw.cpc.toFixed(2) : '0';\n  const comp = kw.competition || '';\n  const src = kw.source || '';\n  return `${i+1}|${kw.keyword}|${vol}|${cpc}|${comp}|${src}`;\n}).join('\\n');\n\n// Use DB prompt or fallback\nlet prompt = '';\nif (promptTemplate) {\n  prompt = promptTemplate\n    .replace(/\\{\\{main_keyword\\}\\}/g, mainKeyword)\n    .replace(/\\{\\{country\\}\\}/g, country)\n    .replace(/\\{\\{language\\}\\}/g, language)\n    .replace(/\\{\\{keyword_list\\}\\}/g, keywordCsv);\n} else {\n  prompt = `Sen bir SEO uzmanisin. Keyword listesini analiz et.\\n\\nAna Keyword: ${mainKeyword}\\nKEYWORDS:\\n${keywordCsv}\\n\\nCIKTI: No|status|intent|cluster|priority|content_type|reject_reason`;\n}\n\nif (customRules) {\n  prompt += `\\n\\nðŸŽ¯ Ã–ZEL KURALLAR:\\n${customRules}`;\n}\n\nreturn [{\n  json: {\n    ...data,\n    skip: false,\n    skipAi: false,\n    filterPrompt: prompt,\n    processedKeywords: aiKeywords,\n    remainingKeywords: remainingKeywords,\n    totalKeywords: allSortedKeywords.length\n  }\n}];"
      },
      "id": "55b4947a-ab6c-4cdb-b89d-62ac04a7a87c",
      "name": "Prepare Filter Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -448,
        96
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "not-skip",
              "leftValue": "={{ $json.skip }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals"
              }
            },
            {
              "id": "not-skip-ai",
              "leftValue": "={{ $json.skipAi }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "3d6dd4f8-05d7-4c1d-904d-9e596616e2c2",
      "name": "IF Run Filter",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -224,
        96
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": {{ JSON.stringify($json.filterPrompt) }}\n    }]\n  }],\n  \"generationConfig\": {\n    \"temperature\": {{ $json.aiTemperature || 0.3 }},\n    \"maxOutputTokens\": 8192\n  }\n}",
        "options": {
          "timeout": 90000
        }
      },
      "id": "ab251c8f-e17a-4fac-a6c8-cb0eebe77469",
      "name": "Gemini Filter",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        0,
        0
      ],
      "credentials": {
        "httpQueryAuth": {
          "id": "Hp8gTY1C1efbSfkx",
          "name": "Gemini API"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// PARSE FILTER RESPONSE (Approved/Rejected)\n// v4: Includes ALL remaining keywords as pending\n// ===========================================\nconst prevData = $('Prepare Filter Prompt').first().json;\nconst geminiResponse = $input.first().json;\nconst processedKeywords = prevData.processedKeywords || [];\nconst remainingKeywords = prevData.remainingKeywords || [];\n\nconst approved = [];\nconst rejected = [];\n\ntry {\n  const text = geminiResponse?.candidates?.[0]?.content?.parts?.[0]?.text || '';\n  const lines = text.split('\\n').filter(l => /^\\d+\\|/.test(l.trim()));\n  \n  for (const line of lines) {\n    const parts = line.split('|').map(p => p.trim());\n    if (parts.length < 2) continue;\n    \n    const no = parseInt(parts[0]);\n    const status = (parts[1] || '').toLowerCase();\n    \n    if (isNaN(no) || no < 1 || no > processedKeywords.length) continue;\n    \n    const original = processedKeywords[no - 1];\n    \n    if (status === 'approved') {\n      approved.push({\n        ...original,\n        index: no,\n        intent: parts[2] && parts[2] !== '' ? parts[2].toLowerCase() : null,\n        cluster: parts[3] && parts[3] !== '' ? parts[3] : null,\n        priority: parts[4] && parts[4] !== '' ? parts[4].toLowerCase() : 'medium',\n        content_type: parts[5] && parts[5] !== '' ? parts[5].toLowerCase() : 'cluster',\n        status: 'approved',\n        reject_reason: null\n      });\n    } else if (status === 'rejected') {\n      const cluster = parts[3] && parts[3] !== '' ? parts[3] : null;\n      const reason = parts[6] && parts[6] !== '' ? parts[6] : 'filtered';\n      rejected.push({\n        ...original,\n        index: no,\n        intent: null,\n        cluster: cluster,\n        priority: null,\n        content_type: null,\n        status: 'rejected',\n        reject_reason: reason\n      });\n    }\n  }\n  \n  // Handle AI-processed keywords that weren't in response\n  const processedIndices = new Set([...approved, ...rejected].map(k => k.index));\n  processedKeywords.forEach((kw, idx) => {\n    if (!processedIndices.has(idx + 1)) {\n      rejected.push({\n        ...kw,\n        index: idx + 1,\n        intent: null,\n        cluster: null,\n        priority: null,\n        content_type: null,\n        status: 'pending',\n        reject_reason: 'AI skipped'\n      });\n    }\n  });\n  \n  // Add ALL remaining keywords (not sent to AI) as pending\n  remainingKeywords.forEach((kw, idx) => {\n    rejected.push({\n      ...kw,\n      index: 150 + idx + 1,\n      intent: null,\n      cluster: null,\n      priority: null,\n      content_type: null,\n      status: 'pending',\n      reject_reason: null\n    });\n  });\n  \n} catch (e) { \n  console.log('Parse error:', e.message);\n  processedKeywords.forEach((kw, idx) => {\n    approved.push({\n      ...kw,\n      index: idx + 1,\n      intent: null,\n      cluster: 'Genel',\n      priority: 'medium',\n      content_type: 'cluster',\n      status: 'approved',\n      reject_reason: null\n    });\n  });\n}\n\nconst clusters = {};\napproved.forEach(kw => {\n  const c = kw.cluster || 'Genel';\n  if (!clusters[c]) clusters[c] = [];\n  clusters[c].push(kw.keyword);\n});\n\nreturn [{\n  json: {\n    mainKeyword: prevData.mainKeyword,\n    projectId: prevData.projectId,\n    clientId: prevData.clientId,\n    stats: {\n      ...prevData.stats,\n      total_processed: processedKeywords.length,\n      approved_count: approved.length,\n      rejected_count: rejected.length,\n      remaining_count: remainingKeywords.length\n    },\n    approved_keywords: approved,\n    rejected_keywords: rejected,\n    all_keywords: [...approved, ...rejected],\n    clusters: clusters,\n    ai_used: true\n  }\n}];"
      },
      "id": "c12570a1-9082-40e2-851e-5fa442731ee5",
      "name": "Parse Filter Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// SKIP AI - Use keywords as-is with defaults\n// v3: All keywords approved by default when AI is skipped\n// ===========================================\nconst data = $input.first().json;\nconst keywords = data.keywords || [];\n\nconst approvedKeywords = keywords.slice(0, 50).map((kw, idx) => ({\n  ...kw,\n  index: idx + 1,\n  intent: null,\n  cluster: 'Genel',\n  priority: 'medium',\n  content_type: 'cluster',\n  status: 'approved',\n  reject_reason: null\n}));\n\n// Remaining keywords are pending\nconst pendingKeywords = keywords.slice(50).map((kw, idx) => ({\n  ...kw,\n  index: idx + 51,\n  intent: null,\n  cluster: 'Beklemede',\n  priority: null,\n  content_type: null,\n  status: 'pending',\n  reject_reason: 'AI analysis skipped - pending review'\n}));\n\nreturn [{\n  json: {\n    mainKeyword: data.mainKeyword,\n    projectId: data.projectId,\n    clientId: data.clientId,\n    stats: {\n      ...data.stats,\n      approved_count: approvedKeywords.length,\n      rejected_count: pendingKeywords.length\n    },\n    approved_keywords: approvedKeywords,\n    rejected_keywords: pendingKeywords,\n    all_keywords: [...approvedKeywords, ...pendingKeywords],\n    clusters: { 'Genel': approvedKeywords.map(k => k.keyword) },\n    ai_used: false\n  }\n}];"
      },
      "id": "4e09e311-9491-44f1-be02-fcbed1df844f",
      "name": "Skip AI Filter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        208
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "has-project",
              "leftValue": "={{ $json.projectId }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "exists"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "7e9b7e8f-d76b-4ed5-b4a0-74ef365c4c73",
      "name": "IF Save to DB",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        448,
        96
      ]
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// PREPARE BATCH INSERT - ALL KEYWORDS WITH STATUS\n// v5: Fixed source normalization for VARCHAR column\n// ===========================================\nlet data = null;\ntry { data = $('Parse Filter Response').first().json; } catch(e) {}\nif (!data) { try { data = $('Skip AI Filter').first().json; } catch(e) {} }\nif (!data) { data = $input.first().json; }\n\nconst projectId = data.projectId;\nconst allKeywords = data.all_keywords || [...(data.approved_keywords || []), ...(data.rejected_keywords || [])];\n\nif (allKeywords.length === 0) {\n  return [{ json: { skip: true, batchQuery: '' } }];\n}\n\nfunction esc(str) {\n  if (str === null || str === undefined) return 'NULL';\n  return \"'\" + String(str).replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"''\") + \"'\";\n}\n\nfunction escOrNull(str) {\n  if (str === null || str === undefined || str === '') return 'NULL';\n  return \"'\" + String(str).replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"''\") + \"'\";\n}\n\n// Normalize source - take first valid source from combined values\nfunction normalizeSource(src) {\n  if (!src) return 'dataforseo';\n  const first = src.split(',')[0].trim();\n  return first || 'dataforseo';\n}\n\n// Build batch VALUES\nconst batchSize = 500;\nconst batches = [];\n\nfor (let i = 0; i < allKeywords.length; i += batchSize) {\n  const batch = allKeywords.slice(i, i + batchSize);\n  const values = batch.map(kw => {\n    const kwType = kw.source?.includes('suggest') ? 'google_suggest' : 'related';\n    const src = normalizeSource(kw.source);\n    return `(${projectId}, ${esc(kw.keyword)}, '${kwType}', ${kw.search_volume || 'NULL'}, ${kw.cpc || 'NULL'}, ${escOrNull(kw.competition)}, ${escOrNull(kw.intent)}, ${escOrNull(kw.cluster)}, ${escOrNull(kw.priority)}, ${escOrNull(kw.content_type)}, '${src}', '${kw.status || 'pending'}', ${escOrNull(kw.reject_reason)})`;\n  }).join(',\\n');\n  \n  const query = `INSERT INTO keyword_results (project_id, keyword, keyword_type, search_volume, cpc, competition, search_intent, keyword_cluster, content_priority, page_type, source, status, reject_reason) VALUES ${values} ON DUPLICATE KEY UPDATE search_volume=VALUES(search_volume), cpc=VALUES(cpc), search_intent=COALESCE(VALUES(search_intent),search_intent), keyword_cluster=COALESCE(VALUES(keyword_cluster),keyword_cluster), content_priority=COALESCE(VALUES(content_priority),content_priority), page_type=COALESCE(VALUES(page_type),page_type), status=VALUES(status), reject_reason=VALUES(reject_reason)`;\n  \n  batches.push({ json: { batchQuery: query, batchIndex: Math.floor(i/batchSize), batchCount: batch.length } });\n}\n\nconsole.log(`[Split for DB] Total: ${allKeywords.length} keywords, ${batches.length} batches`);\nreturn batches;"
      },
      "id": "47235346-5e12-4b44-83b6-12eeeb60d03f",
      "name": "Split for DB",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        0
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.batchQuery }}",
        "options": {}
      },
      "id": "e7fb17bc-8bcf-444e-904b-951979d35708",
      "name": "Save to DB",
      "type": "n8n-nodes-base.mySql",
      "typeVersion": 2.4,
      "position": [
        896,
        0
      ],
      "credentials": {
        "mySql": {
          "id": "1rDLBK64lV00T0am",
          "name": "SEO Suite MySQL"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// PREPARE FINAL RESPONSE\n// v3: Reports both approved and rejected counts\n// ===========================================\nlet data = null;\ntry { data = $('Parse Filter Response').first().json; } catch(e) {}\nif (!data) { try { data = $('Skip AI Filter').first().json; } catch(e) {} }\n\nif (!data) {\n  return [{ json: { success: false, error: 'Could not retrieve data' } }];\n}\n\nconst approvedKeywords = data.approved_keywords || [];\nconst rejectedKeywords = data.rejected_keywords || [];\nconst savedCount = $input.all().length;\n\nreturn [{\n  json: {\n    success: true,\n    message: `Keyword arastirmasi tamamlandi. ${approvedKeywords.length} keyword onaylandi, ${rejectedKeywords.length} reddedildi/beklemede, ${savedCount} DB'ye kaydedildi.`,\n    main_keyword: data.mainKeyword,\n    project_id: data.projectId,\n    stats: {\n      ...data.stats,\n      saved_to_db: savedCount,\n      approved_count: approvedKeywords.length,\n      rejected_count: rejectedKeywords.length\n    },\n    keywords: approvedKeywords.map(kw => ({\n      keyword: kw.keyword,\n      search_volume: kw.search_volume,\n      cpc: kw.cpc,\n      competition: kw.competition,\n      intent: kw.intent,\n      cluster: kw.cluster,\n      priority: kw.priority,\n      content_type: kw.content_type,\n      source: kw.source,\n      status: kw.status\n    })),\n    rejected: rejectedKeywords.map(kw => ({\n      keyword: kw.keyword,\n      search_volume: kw.search_volume,\n      reason: kw.reject_reason,\n      status: kw.status\n    })),\n    clusters: data.clusters || {},\n    ai_used: data.ai_used\n  }\n}];"
      },
      "id": "c9a4c00f-9934-4b47-af6f-5f83b8b27ce5",
      "name": "Response (DB)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// PREPARE RESPONSE (NO DB SAVE)\n// ===========================================\nlet data = null;\ntry { data = $('Parse Filter Response').first().json; } catch(e) {}\nif (!data) { try { data = $('Skip AI Filter').first().json; } catch(e) {} }\nif (!data) { data = $input.first().json; }\n\nconst approvedKeywords = data.approved_keywords || [];\nconst rejectedKeywords = data.rejected_keywords || [];\n\nreturn [{\n  json: {\n    success: true,\n    message: `Keyword arastirmasi tamamlandi. ${approvedKeywords.length} keyword onaylandi, ${rejectedKeywords.length} reddedildi.`,\n    main_keyword: data.mainKeyword,\n    project_id: null,\n    stats: {\n      ...data.stats,\n      saved_to_db: 0\n    },\n    keywords: approvedKeywords.map(kw => ({\n      keyword: kw.keyword,\n      search_volume: kw.search_volume,\n      cpc: kw.cpc,\n      competition: kw.competition,\n      intent: kw.intent,\n      cluster: kw.cluster,\n      priority: kw.priority,\n      content_type: kw.content_type,\n      source: kw.source,\n      status: kw.status\n    })),\n    rejected: rejectedKeywords.map(kw => ({\n      keyword: kw.keyword,\n      reason: kw.reject_reason,\n      status: kw.status\n    })),\n    clusters: data.clusters || {},\n    ai_used: data.ai_used\n  }\n}];"
      },
      "id": "d94e8ee4-4657-4f03-9f84-6c46abb29598",
      "name": "Response (No DB)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        208
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "8c3e3bcd-7259-4254-ab37-cfe54f57c19d",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1344,
        96
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={ \"success\": true, \"message\": \"Keyword bulunamadi\", \"keywords\": [], \"rejected\": [], \"stats\": {} }",
        "options": {}
      },
      "id": "f2a7e84a-4acc-46e1-b29e-fab7355ac891",
      "name": "Respond Empty",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        0,
        400
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "IF Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Valid": {
      "main": [
        [
          {
            "node": "Get Client Config & Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Client Config & Prompt": {
      "main": [
        [
          {
            "node": "Prepare Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Config": {
      "main": [
        [
          {
            "node": "Google Suggestions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Suggestions": {
      "main": [
        [
          {
            "node": "DataForSEO Keywords",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DataForSEO Keywords": {
      "main": [
        [
          {
            "node": "Merge Keywords",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Keywords": {
      "main": [
        [
          {
            "node": "Prepare Filter Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Filter Prompt": {
      "main": [
        [
          {
            "node": "IF Run Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Run Filter": {
      "main": [
        [
          {
            "node": "Gemini Filter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip AI Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini Filter": {
      "main": [
        [
          {
            "node": "Parse Filter Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Filter Response": {
      "main": [
        [
          {
            "node": "IF Save to DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip AI Filter": {
      "main": [
        [
          {
            "node": "IF Save to DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Save to DB": {
      "main": [
        [
          {
            "node": "Split for DB",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response (No DB)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split for DB": {
      "main": [
        [
          {
            "node": "Save to DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to DB": {
      "main": [
        [
          {
            "node": "Response (DB)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response (DB)": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response (No DB)": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "versionId": "v3-with-status",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "962669683927cc1437044c6b20237fcf963b814bc72f0acd8ce7d659ad95be86"
  },
  "id": "j3jZIjdsJSchQqCe",
  "tags": [
    {
      "updatedAt": "2025-12-13T11:18:17.285Z",
      "createdAt": "2025-12-13T11:18:17.285Z",
      "id": "1",
      "name": "Tool1-KeywordResearch"
    }
  ]
}
