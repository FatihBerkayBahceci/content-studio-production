{
  "name": "WF-BULK-KEYWORD: Single Seed v2",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-single-seed",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 0],
      "webhookId": "process-single-seed"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT prompt_text FROM system_prompts WHERE slug = 'bulk-keyword-filter' AND is_active = 1 LIMIT 1"
      },
      "id": "get-prompt",
      "name": "Get Prompt",
      "type": "n8n-nodes-base.mySql",
      "typeVersion": 2.4,
      "position": [220, 0],
      "credentials": {"mySql": {"id": "1rDLBK64lV00T0am", "name": "SEO Suite MySQL"}},
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.dataforseo.com/v3/keywords_data/google_ads/keywords_for_keywords/live",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {"name": "Authorization", "value": "Basic b2t0YXlAc2VvYXJ0LmNvbTo0ODk2ZGRhYzQ2OWUyZjIw"},
            {"name": "Content-Type", "value": "application/json; charset=utf-8"}
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "=[{\"keywords\": [\"{{ $('Webhook').first().json.body.seed }}\"], \"location_code\": {{ $('Webhook').first().json.body.locationCode }}, \"language_code\": \"{{ $('Webhook').first().json.body.language }}\", \"include_seed_keyword\": true, \"sort_by\": \"search_volume\"}]",
        "options": {
          "timeout": 60000,
          "response": {
            "response": {
              "responseFormat": "text"
            }
          }
        }
      },
      "id": "dfs",
      "name": "DataForSEO",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [440, 0],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const input = $('Webhook').first().json.body;\nconst rawResponse = $input.first().json.data || $input.first().json;\nconst seed = input.seed;\n\n// Get prompt template from DB\nconst promptTemplate = $('Get Prompt').first().json.prompt_text || '';\n\n// Parse JSON from text response to preserve encoding\nlet dfs;\ntry {\n  dfs = typeof rawResponse === 'string' ? JSON.parse(rawResponse) : rawResponse;\n} catch(e) {\n  dfs = rawResponse;\n}\n\nlet keywords = [];\ntry {\n  if (dfs?.tasks?.[0]?.result) {\n    keywords = dfs.tasks[0].result.map(k => ({\n      kw: (k.keyword || '').toLowerCase().trim(),\n      vol: k.search_volume || 0,\n      cpc: k.cpc || 0\n    })).filter(k => k.kw.length >= 2);\n  }\n} catch(e) {}\n\n// Dedupe\nconst seen = new Set();\nconst unique = keywords.filter(k => {\n  if (seen.has(k.kw)) return false;\n  seen.add(k.kw);\n  return true;\n}).slice(0, 500);\n\nif (unique.length === 0) {\n  return [{json: {\n    seed,\n    approved: [],\n    rejected: [],\n    stats: {approved: 0, rejected: 0}\n  }}];\n}\n\nconst kwList = unique.map((k, i) => `${i+1}|${k.kw}|${k.vol}`).join('\\n');\n\n// Build prompt from template or fallback\nlet prompt;\nif (promptTemplate && promptTemplate.length > 50) {\n  prompt = promptTemplate\n    .replace(/\\{\\{seed\\}\\}/g, seed)\n    .replace(/\\{\\{keyword_list\\}\\}/g, kwList);\n} else {\n  // Fallback prompt if DB fetch fails\n  prompt = `\"${seed}\" için anahtar kelime analizi.\\n\\nKEYWORDS (no|keyword|volume):\\n${kwList}\\n\\nGÖREV: İçerik oluşturmaya EN UYGUN 35 keyword seç.\\n\\nSEÇİM KRİTERLERİ:\\n- Blog/makale/rehber yazılabilir mi?\\n- Kullanıcıya değer katan bilgi içeriyor mu?\\n- Arama amacı bilgi edinme mi?\\n\\nSEÇME (ama DİĞER olarak kaydet):\\n- Marka+model kombinasyonları\\n- Fiyat/satın alma sorguları\\n- Çok genel tek kelimeler\\n\\nÇIKTI FORMATI (TEK SATIR):\\nCONTENT:1,5,8,12,15,23,45,67\\n\\nAÇIKLAMA YAZMA. SADECE NUMARALAR.`;\n}\n\nreturn [{json: {seed, keywords: unique, prompt}}];"
      },
      "id": "parse-dfs",
      "name": "Parse DFS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 0]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\"contents\":[{\"parts\":[{\"text\":{{ JSON.stringify($json.prompt) }}}]}],\"generationConfig\":{\"temperature\":0.1,\"maxOutputTokens\":4096}}",
        "options": {"timeout": 60000}
      },
      "id": "gemini",
      "name": "Gemini",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [880, 0],
      "credentials": {"httpQueryAuth": {"id": "Hp8gTY1C1efbSfkx", "name": "Gemini API"}},
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const prev = $('Parse DFS').first().json;\nconst gemini = $input.first().json;\nconst seed = prev.seed;\nconst kws = prev.keywords || [];\n\nconst normalize = (str) => {\n  return str\n    .toLowerCase()\n    .replace(/ı/g, 'i')\n    .replace(/ğ/g, 'g')\n    .replace(/ü/g, 'u')\n    .replace(/ş/g, 's')\n    .replace(/ö/g, 'o')\n    .replace(/ç/g, 'c')\n    .replace(/[^a-z0-9\\s]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst hasTurkishChars = (str) => /[ıİğĞüÜşŞöÖçÇ]/.test(str);\n\nconst pickBest = (existing, newKw) => {\n  const existingTr = hasTurkishChars(existing.kw);\n  const newTr = hasTurkishChars(newKw.kw);\n  if (newTr && !existingTr) return newKw;\n  if (existingTr && !newTr) return existing;\n  return newKw.vol > existing.vol ? newKw : existing;\n};\n\nconst approved = [];\nconst rejected = [];\nconst contentSet = new Set();\n\ntry {\n  const txt = gemini?.candidates?.[0]?.content?.parts?.[0]?.text || '';\n  \n  const contentMatch = txt.match(/CONTENT[:\\s]*([\\d,\\s]+)/i);\n  const contentNos = contentMatch \n    ? contentMatch[1].split(',').map(n => parseInt(n.trim())).filter(n => n > 0 && n <= kws.length)\n    : [];\n  \n  const approvedMap = new Map();\n  contentNos.forEach(n => {\n    const k = kws[n - 1];\n    if (k) {\n      contentSet.add(n - 1);\n      const norm = normalize(k.kw);\n      if (approvedMap.has(norm)) {\n        approvedMap.set(norm, pickBest(approvedMap.get(norm), k));\n      } else {\n        approvedMap.set(norm, k);\n      }\n    }\n  });\n  \n  approvedMap.forEach((k, norm) => {\n    approved.push({\n      keyword: k.kw,\n      seed_keyword: seed,\n      search_volume: k.vol,\n      cpc: k.cpc,\n      status: 'approved',\n      priority: k.vol >= 5000 ? 'high' : k.vol >= 1000 ? 'medium' : 'low'\n    });\n  });\n  \n  const rejectedMap = new Map();\n  const approvedNorms = new Set(approvedMap.keys());\n  \n  kws.forEach((k, idx) => {\n    if (contentSet.has(idx)) return;\n    const norm = normalize(k.kw);\n    if (approvedNorms.has(norm)) return;\n    \n    if (rejectedMap.has(norm)) {\n      rejectedMap.set(norm, pickBest(rejectedMap.get(norm), k));\n    } else {\n      rejectedMap.set(norm, k);\n    }\n  });\n  \n  rejectedMap.forEach((k, norm) => {\n    rejected.push({\n      keyword: k.kw,\n      seed_keyword: seed,\n      search_volume: k.vol,\n      cpc: k.cpc,\n      status: 'rejected'\n    });\n  });\n  \n} catch(e) {\n  const sorted = [...kws].sort((a, b) => b.vol - a.vol);\n  const approvedMap = new Map();\n  const rejectedMap = new Map();\n  \n  sorted.forEach((k, idx) => {\n    const norm = normalize(k.kw);\n    const isTop35 = idx < 35;\n    const targetMap = isTop35 ? approvedMap : rejectedMap;\n    \n    if (isTop35 && rejectedMap.has(norm)) return;\n    if (!isTop35 && approvedMap.has(norm)) return;\n    \n    if (targetMap.has(norm)) {\n      targetMap.set(norm, pickBest(targetMap.get(norm), k));\n    } else {\n      targetMap.set(norm, k);\n    }\n  });\n  \n  approvedMap.forEach((k) => {\n    approved.push({\n      keyword: k.kw,\n      seed_keyword: seed,\n      search_volume: k.vol,\n      cpc: k.cpc,\n      status: 'approved',\n      priority: k.vol >= 5000 ? 'high' : k.vol >= 1000 ? 'medium' : 'low'\n    });\n  });\n  \n  rejectedMap.forEach((k) => {\n    rejected.push({\n      keyword: k.kw,\n      seed_keyword: seed,\n      search_volume: k.vol,\n      cpc: k.cpc,\n      status: 'rejected'\n    });\n  });\n}\n\nif (approved.length === 0 && kws.length > 0) {\n  const sorted = [...kws].sort((a, b) => b.vol - a.vol);\n  const approvedMap = new Map();\n  const rejectedMap = new Map();\n  \n  sorted.forEach((k, idx) => {\n    const norm = normalize(k.kw);\n    const isTop35 = approvedMap.size < 35 && !rejectedMap.has(norm);\n    const targetMap = isTop35 ? approvedMap : rejectedMap;\n    \n    if (!isTop35 && approvedMap.has(norm)) return;\n    \n    if (targetMap.has(norm)) {\n      targetMap.set(norm, pickBest(targetMap.get(norm), k));\n    } else {\n      targetMap.set(norm, k);\n    }\n  });\n  \n  approvedMap.forEach((k) => {\n    approved.push({\n      keyword: k.kw,\n      seed_keyword: seed,\n      search_volume: k.vol,\n      cpc: k.cpc,\n      status: 'approved',\n      priority: 'medium'\n    });\n  });\n  \n  rejectedMap.forEach((k) => {\n    rejected.push({\n      keyword: k.kw,\n      seed_keyword: seed,\n      search_volume: k.vol,\n      cpc: k.cpc,\n      status: 'rejected'\n    });\n  });\n}\n\nreturn [{json: {\n  seed,\n  approved,\n  rejected,\n  stats: {\n    approved: approved.length,\n    rejected: rejected.length\n  }\n}}];"
      },
      "id": "parse-gemini",
      "name": "Parse Gemini",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 0]
    }
  ],
  "connections": {
    "Webhook": {"main": [[{"node": "Get Prompt", "type": "main", "index": 0}]]},
    "Get Prompt": {"main": [[{"node": "DataForSEO", "type": "main", "index": 0}]]},
    "DataForSEO": {"main": [[{"node": "Parse DFS", "type": "main", "index": 0}]]},
    "Parse DFS": {"main": [[{"node": "Gemini", "type": "main", "index": 0}]]},
    "Gemini": {"main": [[{"node": "Parse Gemini", "type": "main", "index": 0}]]}
  },
  "settings": {"executionOrder": "v1"}
}
